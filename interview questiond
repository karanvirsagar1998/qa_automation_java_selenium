https://chatgpt.com/share/6938f607-fb6c-8004-b511-64f54c0f83d9

✅ TOP 40 JAVA + SELENIUM INTERVIEW QUESTIONS WITH BEST ANSWERS
1. Question: Explain the architecture of Selenium WebDriver.

Answer:
Selenium WebDriver follows a client–server architecture using a JSON Wire Protocol (and W3C WebDriver standard now).
Here’s how it works:

Automation Script (Java code) sends commands like click(), get(), etc.

WebDriver API converts these commands into HTTP requests.

Browser Driver (ChromeDriver/GeckoDriver) receives the request on a port.

The browser driver communicates directly with the browser using native automation engines.

Browser executes the commands and returns the response.

Example:
When I call driver.findElement(By.id("login")).click():

Java sends instruction → ChromeDriver

ChromeDriver → Chrome

Chrome performs click → Returns success response.

This shows I understand communication flow end-to-end.

2. Question: Difference between findElement and findElements.

Answer:

findElement returns the first matching element. If not found → throws NoSuchElementException.

findElements returns a List of elements. If none found → returns empty list (no exception).

Example:

List<WebElement> rows = driver.findElements(By.tagName("tr"));
if(rows.size() == 0) {
    System.out.println("No rows found — handled safely");
}

3. Question: Explain implicit, explicit, and fluent waits.

Answer:

Implicit Wait

Applies globally for all elements.

Example: driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);

Explicit Wait

Waits for specific condition for specific element.

new WebDriverWait(driver, 10).until(ExpectedConditions.elementToBeClickable(btn));

Fluent Wait

Same as explicit but allows:

Polling frequency

Ignoring exceptions

Wait<WebDriver> wait = new FluentWait<>(driver)
    .withTimeout(Duration.ofSeconds(20))
    .pollingEvery(Duration.ofSeconds(2))
    .ignoring(NoSuchElementException.class);


I use explicit wait the most because it avoids unnecessary delays.

4. Question: What are different types of locators?

Answer:
Selenium provides 8 locators:
ID, Name, ClassName, TagName, LinkText, PartialLinkText, XPath, CSS Selector.

Locator preference:
ID → Name → CSS → XPath.

I avoid absolute XPath because it’s unstable.

5. Question: How do you handle dynamic web elements?

Answer:
I use dynamic XPath/CSS with:

contains()

starts-with()

text()

following-sibling

parent/ancestor relationships

Example:
//input[contains(@id,'email_')]

Or
//button[text()='Checkout']/parent::div/following-sibling::div/button

6. Question: How do you handle scrolling, iframes, windows, and shadow DOM?

Answer:

Scrolling
JavascriptExecutor js = (JavascriptExecutor) driver;
js.executeScript("arguments[0].scrollIntoView(true);", element);

iFrames
driver.switchTo().frame("frameName");
driver.switchTo().defaultContent();

Multiple Windows
for(String win : driver.getWindowHandles()){
    driver.switchTo().window(win);
}

Shadow DOM

Use JS because Selenium can't access it directly:

WebElement shadowHost = driver.findElement(By.css("shadow-host"));
SearchContext shadowRoot = shadowHost.getShadowRoot();

7. Question: Explain StaleElementReferenceException.

Answer:
It occurs when the element is no longer attached to the DOM.

Causes:

Page reload

DOM refreshed

Element changes position dynamically

Solution:
Re-locate the element using explicit wait.

WebElement element = wait.until(ExpectedConditions
                                .refreshed(ExpectedConditions.visibilityOfElementLocated(locator)));

8. Question: How do you verify if an element is displayed without using isDisplayed()?

Answer:

try {
    driver.findElement(locator);
    return true;
} catch (NoSuchElementException e) {
    return false;
}


Or verify through CSS:

element.getCssValue("display").equals("none")

9. Question: How do you handle a table with 500+ rows?

Answer:
I loop through each row and match text:

List<WebElement> rows = driver.findElements(By.xpath("//table/tbody/tr"));
for(WebElement row : rows){
    if(row.getText().contains("Karan Singh")) {
        row.findElement(By.xpath(".//button[text()='Edit']")).click();
        break;
    }
}


Efficient and reusable.

10. Question: How do you automate file download?

Answer:
In Chrome, I preset the download directory using ChromeOptions, then verify the file exists.

Map<String, Object> prefs = new HashMap<>();
prefs.put("download.default_directory", "C:\\Downloads");

ChromeOptions options = new ChromeOptions();
options.setExperimentalOption("prefs", prefs);


Then check:

new File("C:\\Downloads\\report.pdf").exists();

11. Question: How to upload files without AutoIT/Robot?

Answer:
Use sendKeys():

driver.findElement(By.id("upload")).sendKeys("C:\\files\\resume.pdf");


Works only for input[type='file'].

12. Question: How do you extract table data into List/Map?

Answer:

List<String> names = new ArrayList<>();
for(WebElement row : rows){
    names.add(row.findElement(By.xpath("./td[1]")).getText());
}


For Map:
<EmployeeName, Salary>

13. Question: How to handle a random alert?

Answer:

try {
    WebDriverWait wait = new WebDriverWait(driver, 3);
    wait.until(ExpectedConditions.alertIsPresent());
    driver.switchTo().alert().accept();
} catch (Exception e) {
    System.out.println("No alert");
}

14. Question: Explain OOP concepts used in your framework.

Answer:

Encapsulation:

I keep locators + methods inside Page classes.

Abstraction:

I expose only necessary methods to test layer.

Inheritance:

Base class → common methods
Page classes → extend BasePage

Polymorphism:

Method overloading (e.g., click with timeout).
Method overriding (e.g., different implementations for different browsers).

15. Question: Abstraction vs Encapsulation in Selenium?

Answer:

Encapsulation: Hide locators and expose only methods.

Abstraction: User doesn’t know underlying Selenium calls.

Example:
loginPage.login("user", "pass")
Internally handles waits, clicking, sending text.

16. Question: How do you use Collections in automation?

Answer:

List → all rows

Map → key-value data from excel

Set → unique dropdown values

Queue → storing tasks for parallel execution

17. Question: String vs StringBuilder vs StringBuffer

Answer:

String: immutable, thread-safe

StringBuilder: mutable, faster, not thread-safe

StringBuffer: mutable, thread-safe

I use StringBuilder to build long dynamic XPaths.

18. Question: Explain exception handling + retry mechanism.

Answer:
Use try/catch for element not found.
For retry logic → TestNG RetryAnalyzer.

public boolean retry(ITestResult result) {
    return retryCount++ < 2;
}

19. Question: Explain your automation framework architecture.

Answer:
I’ve built a Hybrid framework with:

Page Object Model

Data-driven (Excel/JSON)

TestNG

Utility classes

Reusable Actions

Logging (Log4j)

Reporting (Extent / Allure)

CI/CD via Jenkins

20. Question: POM advantages/disadvantages

Answer:

✔ Advantages

Reuse

Maintainability

Separation of UI + Test logic

❌ Disadvantages

More classes

Initial setup time

21. Question: How do you manage test data?

Answer:
Externalize test data using:

Excel

JSON

Properties files

Environment variables (Staging/Prod)

22. Question: What reporting tools have you used?

Answer:

Extent Reports – screenshots, logs

Allure – graphs, test history

I integrate reports in Jenkins.

23. Question: How do you manage utilities?

Answer:
I create separate utility layers:

WaitUtils

ElementActions

FileUtils

DBUtils

ScreenshotUtils

Reusable across entire project.

24–28. TestNG answers summarized:

I explain annotations, parallel execution, soft vs hard asserts, RetryAnalyzer with real examples.

29. Question: Have you automated APIs?

Answer:
Yes — using RestAssured.

given().get("/users/2").then().statusCode(200);


I validate UI → API → DB consistency.

30. Question: How do you validate backend data?

Answer:
I use JDBC to run SQL queries:

ResultSet rs = stmt.executeQuery("SELECT name FROM users WHERE id=2");


Compare SQL result with UI.

31. Question: How to integrate UI + API tests?

Answer:
Use API to create data, UI to validate flow.

32–34. Jenkins + Git answers:

I explain pipelines, triggers, fixing failures, branching strategies.

35. Question: Test passes locally but fails in Jenkins?

Answer:
I check:

Wait issues

Resolution difference

Environment URLs

Missing dependencies

Different browser versions

36. Question: Locator keeps changing — what do you do?

Answer:

Use stable attributes

Use parent/child structure

Ask developer to add unique data-testid attribute

Use regex-based XPath

37. Question: Most challenging automation bug?

Answer:
Give an example:
“Sync issue on React application. Element visible but not interactable. Fixed using JS click + explicit wait.”

38. Question: Describe your project role.

Answer:

Designing framework

Writing test cases

Handling CI/CD

Reviewing merge requests

Maintaining scripts

Reporting defects

39. Question: How do you estimate automation effort?

Answer:

Complexity

Reusability

Test data

UI stability

Environment readiness

Thumb rule:
1 test = 2–4 hours depending on complexity.

40. Question: Developer says bug is not reproducible — what do you do?

Answer:

Provide logs

Provide steps

Provide video/screenshot

Retest on clean environment

Check backend and browser logs

Confirm environment/version mismatch

✅ If you want, I can also prepare you for a LIVE mock interview

I’ll ask 10–15 questions, you answer, and I’ll tell you:
✔ What you answered well
✔ What you should improve
✔ What hiring managers look for

Just say "Start mock interview".
